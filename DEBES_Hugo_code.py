# -*- coding: utf-8 -*-
"""Datascience et IA : Approximation d'une fonction (class version).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1e7p76bxHUFlbqSbzTEf_JsCklhRglbr8

1)
Importons toutes les librairies et modules dont nous aurons besoin pour l'execution du code
"""

from math import cos,pi
import random
import pandas as pd
import numpy as np

"""2) Connectons notre Notebook Google Colab avec mon Google Drive pour avoir accès à mes documents (+vérification)"""

# Commented out IPython magic to ensure Python compatibility.
try:
    from google.colab import drive
    drive.mount('/content/drive', force_remount=True)
    COLAB = True
    print("Note: using Google CoLab")
#     %tensorflow_version 2.x
except:
    print("Note: not using Google CoLab")
    COLAB = False

"""3)Chargeons notre dataset de points"""

temperature_sample = '/content/drive/MyDrive/ESILV/temperature2.csv'
#temperature_sample = '/content/drive/MyDrive/ESILV/temperature_sample.csv'
data = pd.read_csv(temperature_sample,sep=';')
data=data.rename(columns={'#i':'i'})
data.head()

"""4)Création de la classe individu du problème avec 3 paramètres (a,b,c)"""

class individu:
  def __init__(self,a=None,b=None,c=None):
    if (a==None or a<=0 or a>=1):
      self.a = round(random.uniform(0.01,0.99),3)
    else:
      self.a=a
    if (b==None or b>20 or b<1):
      self.b = random.randint(1,20)
    else:
      self.b=b
    if (c==None or c>20 or c<1):
      self.c = random.randint(1,20)
    else:
      self.c=c
    self.distance_reel = self.fitness(data)
  def affichage(self):
    print('Cet individu représente une fonction de Weierstrass de paramètres : a = {} , b = {} , c = {}'.format(self.a,self.b,self.c))
  def __str__(self):
    return f' a = {self.a} , b = {self.b} , c = {self.c}'
  def weierstrass(self,i):
    result=0
    for n in range(self.c+1):
      ite = (self.a**n)*(cos((self.b**n)*pi*i))
      result = result+ite
    return result
  def distance(self,index,data): #valeur absolue de la distance entre la valeur trouvée et la réalité
    return abs((self.weierstrass(data.iloc[index][0])-data.iloc[index][1]))
  def fitness(self,data): # somme des distances (fonction de coût)
    distance_totale=0
    for index in range(len(data)-1):
      distance_totale += self.distance(index,data)
    return distance_totale
  def __setitem__(self,a=None,b=None,c=None):
    if (b!=None):
        self.b=b
    if (a!=None):
        self.a=a
    if (c!=None):
        self.c=c
  def __getitem__(self,val):       
    if isinstance(val,str):
        if(val=="a"):
          result = self.a
        if(val=="b"):
          result = self.b
        if(val=="c"):
          result = self.c
    else:
      result=None
    return result
  def __eq__(self,ind2):  
    result=False
    if (self.a==ind2.a and self.b==ind2.b and self.c==ind2.c):
      result=True
    return result 
  def __lt__(self,ind2):
    if (self.fitness(data)<ind2.fitness(data)):
        return self < ind2

"""5) Création de notre population composée de n_pop individus + Affichage"""

def generationPopulation(n_pop):
  if (n_pop<0):
    n_pop=10
  pop=[]
  for i in range(n_pop):
    pop.append(individu())
  return pop

def affichagePopulation(pop):
  for i in range(len(pop)):
      print(pop[i])

"""6) Fonction d'évaluation et de sélection de notre population"""

def evaluatebis(pop):
  return sorted(pop,key=lambda individu : individu.distance_reel)

def selectionbis(pop,n_best,n_worst):
  return pop[:n_best]+pop[len(pop)-n_worst:]

"""7) Fonction de croisement entre 2 individus "parents" donnant 2 individus "fils"
*   Moyenne/Changement de décimale pour a
*   Inversion pour b et c
"""

def croisementbis(c1,c2):
  c3=individu(round(((c1.a+c2.a)/2),3),c1.b,c2.c)
  new_a  = eval(str(c1.a)[:-2]+str(c1.a)[-1]+str(c1.a)[-2])
  if (new_a>1):
    new_a = round(random.uniform(0.01,0.99),3)
  c4=individu(new_a,c2.b,c1.c)
  return c3,c4

"""8) Fonction de mutation d'un individu  

 Paramètre aléatoire incrémentant ou décrémentant les valeurs d'un individu
"""

def mutationbis(c1):
  a=random.randrange(2)
  result=individu()
  if (a==1):
    result = individu(round((c1.a-0.05),3),c1.b+1,c1.c-1)
  if (a==0):
    result = individu(round((c1.a+0.05),3),c1.b-1,c1.c+1)
  if (result.b<1 or result.b>20):
    result.b=random.randint(1,20)
  if (result.c<1 or result.c>20):
    result.c=random.randint(1,20)
  if (result.a<0 or result.a>1):
    result.a=round(random.uniform(0,1),3)
  return result

"""9) Pour tous les individus de la population nous appliquons les opérations de croisement et de mutation"""

def croisement_pop(pop):
  new_gen=[]
  if (len(pop)%2!=0):
    pop.append(individu())
  for i in range(0,len(pop),2):
    new_ind1, new_ind2 = croisementbis(pop[i],pop[i+1])   
    new_gen.append(new_ind1)
    new_gen.append(new_ind2)
  return new_gen

def mutation_pop(pop_select):
  mutants=[]
  for i in range(len(pop_select)):
    mutants.append(mutationbis(pop_select[i]))
  return mutants

"""10) Fonction de vérification et d'arrêt de la boucle finale  """

def verif(pop,stop,precision):
  print(pop[0]," a la meilleure fitness soit ",pop[0].fitness(data))
  if (pop[0].fitness(data)<precision):
    stop=True
    print("Win !")
  return stop
  
def stop(ite,n_epoch,pop,cond_stop_performance):
  cond_stop=False
  if (ite>=n_epoch or len(pop)<=2 or cond_stop_performance==True ):
    cond_stop=True  
  return cond_stop

"""11) Boucle finale du Problème"""

def boucle_finalv2(precision):
  n_epoch=20 #nombre de générations maximales
  n_pop=10 #nombre d'individus de la population de départ
  population = generationPopulation(n_pop)
  coeff_best=0.35 #pourcentage des meilleurs éléments sélectionnés 
  coeff_worst=0.15 #pourcentage des pires éléments sélectionnés 
  ite=0 #génération en cours 
  cond_stop_performance=False #arrêt du programme si le meilleur individu dépasse nos attentes de performance 
  cond_stop=stop(ite,n_epoch,population,cond_stop_performance)
  stock=[] #liste de l'ensemble du meilleur individu de chaque génération 
  win=False
  stuck = 1 if precision*3<=1 else precision*3 #le programme est bloqué dans un min local si la fitness est au dessus de cette variable
  while (cond_stop == False):
    print("Generation n° ",ite+1)
    ite+=1
    cond_stop=stop(ite,n_epoch,population,cond_stop_performance)
    eval_pop = evaluatebis(population) #évaluation de notre population actuelle 
    stock.append(eval_pop[0].distance_reel)
    cond_stop_performance = verif(eval_pop,cond_stop_performance,precision)
    if (cond_stop_performance==True): #fin du programme si on dépasse l'objectif de performance
      result=eval_pop[0]
      cond_stop=True
      win=True
      break
    else: 
      selection_pop = selectionbis(eval_pop,int(coeff_best*len(eval_pop)),int(coeff_worst*len(eval_pop))) #sélection
      random.shuffle(selection_pop) #mélange de nos individus qu'ils aient une bonne ou mauvaise fitness
      croises = croisement_pop(selection_pop) #croisement
      mutes = mutation_pop(selection_pop) # mutation
      new_ind=[]
      for i in range(5): #ajout de nouveaux individus aléatoires pour apporter de la diversité (évite l'eugnénisme)
        new_ind.append(individu())
      population = croises[:]+mutes[:]+new_ind[:] #nouvelle population pour la génération suivante 
      if (len(population)>30): #notre population augmente légèrement, on supprime quelques éléments (rapidité de l'algorithme)
        population = population[:30]
      if (len(stock)>=7 and np.mean(stock[6:])>stuck): #si la moyenne des fitness des meilleurs éléments est au dela de stuck,
        population=generationPopulation(n_pop)        #on se considère dans un min local et on regénère une population
        stock[:]=[]
        print("Regénération de la population...")
  if (cond_stop_performance==False): #si on ne trouve pas des éléments, on se contente du meilleur actuel 
    result=eval_pop[0]
    print("Lose...")
  return result,win #on retourne l'individu et si la condition de performance est remplie

"""12) Comparatif d'un individu avec toutes les valeurs de notre dataset + écart """

def comparatif(best,dataset):
  print("Fitness globale :",best.fitness(data))
  for i in range(len(dataset)-1):
    print("i : ",dataset.iloc[i][0])
    print("Résultat trouvé: " , best.weierstrass(dataset.iloc[i][0]))
    print("Réalité :",dataset.iloc[i][1])
    print("Ecart :",abs((best.weierstrass(dataset.iloc[i][0])-dataset.iloc[i][1])/dataset.iloc[i][1]))

"""13) Résultat et temps d'execution"""

# Commented out IPython magic to ensure Python compatibility.
best,win  = boucle_finalv2(0.2)
print("Best:",best)
print("Fitness:",best.distance_reel)

"""14) Main du programme

(A considérer si on a aucune idée de la précision que l'on peut atteindre avec un set de données)
1.   On considère une précision de départ 
2.   Le but de cette boucle est d'utiliser la boucle_final() et de diminuer la précision recherchée si celle-ci a été rempli précédemment
3.   Si la boucle_final() ne bat pas la précision 3 fois d'affilée on arrète la recherche

"""

if __name__=="__main__":
  precision=2 #précision de départ 
  stop_def=False #stop définitif du programme 
  stop_compteur=0
  winner_list=[]
  while (stop_def==False): 
    result,win=boucle_finalv2(precision)
    if (win==True): #précision battue on peut continuer à minimiser notre fonction de fitness
      precision -=0.2
      stop_compteur=0
      winner_list.append(result)
    else:
      stop_compteur+=1 
      if (result.distance_reel <evaluatebis(winner_list)[0].distance_reel): # cas où on ne bat pas la précision mais on s'en approche
        winner_list.append(result)
    if (stop_compteur==3): #trois boucles sans amélioration on arrète la recherche 
      stop_def=True
  print("Precision atteinte :",precision )
  print("Best : ",evaluatebis(winner_list)[0])
  print("Fitness : ",evaluatebis(winner_list)[0].distance_reel)